body:             |
  bb.1.entry:
    successors: %bb.2(0x80000000)
2:
    %265 = LDImm target-flags(lo) @flags

3:
    %266 = LDImm target-flags(hi) @flags

    %267 = REG_SEQUENCE %265, %subreg.sublo, %266, %subreg.subhi

5:
    %2 = LDImm 1

6:
    %263 = LDImm -1

7:
    %264 = LDImm 31

8:
    %11 = LDImm 0

9:
    %262 = LDImm 3

10:
    %227 = LDImm1 0

11:
    %216 = LDImm 0

  bb.2.for.cond1.preheader:
    successors: %bb.3(0x80000000)
    %258 = PHI %2, %bb.1, %67, %bb.9, %67, %bb.11
    %259 = PHI %11, %bb.1, %68, %bb.9, %68, %bb.11

2:
    ADJCALLSTACKDOWN 0, 0, implicit-def $rs0, implicit $rs0

3:
Preds: 2
    $rs1 = COPY %267

4:
Preds: 2
    $a = COPY %2

5:
Preds: 2
    $x = COPY %263

6:
Preds: 2
    $rc4 = COPY %264

7:
Preds: 2 3 4 5 6
    JSR &__memset, mos_csr, implicit $rs1, implicit $a, implicit $x, implicit $rc4

8:
Preds: 7
    ADJCALLSTACKUP 0, 0, implicit-def $rs0, implicit $rs0

9:
  <end>
  
  bb.3.for.body6:
    successors: %bb.8(0x30000000), %bb.4(0x50000000)
  
    %250 = PHI %262, %bb.2, %94, %bb.8, %94, %bb.17
    %251 = PHI %11, %bb.2, %96, %bb.8, %96, %bb.17
    %244 = PHI %262, %bb.2, %102, %bb.8, %102, %bb.17
    %245 = PHI %11, %bb.2, %104, %bb.8, %104, %bb.17
    %238 = PHI %11, %bb.2, %114, %bb.8, %114, %bb.17
    %239 = PHI %11, %bb.2, %115, %bb.8, %115, %bb.17
    %232 = PHI %11, %bb.2, %108, %bb.8, %108, %bb.17
    %233 = PHI %11, %bb.2, %109, %bb.8, %109, %bb.17

3:
    %223, %224, dead %284 = ADCImm %232, target-flags(lo) @flags, %227


5:
Preds: 3
    %225, dead %226, dead %282 = ADCImm %233, target-flags(hi) @flags, %224

    %218 = REG_SEQUENCE %223, %subreg.sublo, %225, %subreg.subhi

7:
Preds: 3 5
    %10 = LDIndirIdx %218, %216 :: (load (s8) from %ir.arrayidx7, !tbaa !3)

    CmpBrZero %bb.8, undef $z, 1, %10, implicit-def $c
    JMP %bb.4
  
  bb.4.if.then:
    successors: %bb.26(0x40000000), %bb.27(0x40000000)

2:
    %206, %207 = ASL %232

3:
Preds: 2
    %208, dead %203 = ROL %233, %207

4:
Preds: 2
    %197, %198, dead %281 = ADCImag8 %206, %232, %227

5:
Preds: 3 4
    %199, dead %200, dead %280 = ADCImag8 %208, %233, %198

6:
Preds: 4
    %188, %189, dead %279 = ADCImm %197, 3, %227

7:
Preds: 5 6
    %190, dead %191, dead %278 = ADCImm %199, 0, %189

    CmpBrImm %bb.26, undef $z, 1, %190, 31, implicit-def $c
    JMP %bb.27
  
  bb.26.if.then:
    successors: %bb.7(0x40000000), %bb.28(0x40000000)
  
2:
    %175 = CMPImm %188, 255

    GBR %bb.7, %175, 1, implicit-def $c
    JMP %bb.28
  
  bb.27.if.then:
    successors: %bb.7(0x40000000), %bb.28(0x40000000)
  
1:
    %180 = CMPImm %190, 31

    GBR %bb.7, %180, 1, implicit-def $c
    JMP %bb.28
  
  bb.28.if.then:
    successors: %bb.5(0x80000000)

    JMP %bb.5
  
  bb.5.while.body.preheader:
    successors: %bb.6(0x80000000)
  

  bb.6.while.body:
    successors: %bb.23(0x40000000), %bb.24(0x40000000)
  
    %164 = PHI %244, %bb.5, %144, %bb.23, %144, %bb.24
    %165 = PHI %245, %bb.5, %146, %bb.23, %146, %bb.24

2:
    %156, %157, dead %277 = ADCImm %164, target-flags(lo) @flags, %227

3:
Preds: 2
    %158, dead %159, dead %276 = ADCImm %165, target-flags(hi) @flags, %157

    %151 = REG_SEQUENCE %156, %subreg.sublo, %158, %subreg.subhi

5:
Preds: 2 3
    STIndirIdx %11, %151, %216 :: (store (s8) into %ir.scevgep, !tbaa !3)

6:
    %144, %145:cc, dead %274 = ADCImag8 %164, %250, %227

7:
Preds: 6
    %146, dead %147, dead %272 = ADCImag8 %165, %251, %145

    CmpBrImm %bb.23, undef $z, 1, %146, 31, implicit-def $c
    JMP %bb.24
  
  bb.23.while.body:
    successors: %bb.6(0x40000000), %bb.25(0x40000000)
  
2:
    %131 = CMPImm %144, 255

    GBR %bb.6, %131, 0, implicit-def $c
    JMP %bb.25
  
  bb.24.while.body:
    successors: %bb.6(0x40000000), %bb.25(0x40000000)
  
1:
    %136 = CMPImm %146, 31

    GBR %bb.6, %136, 0, implicit-def $c
    JMP %bb.25
  
  bb.25.while.body:
    successors: %bb.7(0x80000000)
  
    JMP %bb.7
  
  bb.7.while.end:
    successors: %bb.8(0x80000000)
  
1:
    %118, %119 = IncMB %238(tied-def 0), %239(tied-def 1), implicit-def $c, implicit-def $v
  
  bb.8.for.inc14:
    successors: %bb.17(0x40000000), %bb.3(0x40000000)
  
    %114 = PHI %118, %bb.7, %238, %bb.3
    %115 = PHI %119, %bb.7, %239, %bb.3

1:
    %108, %109 = IncMB %232(tied-def 0), %233(tied-def 1), implicit-def $c, implicit-def $v

2:
    %102, %103, dead %271 = ADCImm %244, 3, %227

3:
Preds: 2
    %104, dead %105, dead %270 = ADCImm %245, 0, %103

4:
    %94, %95, dead %269 = ADCImm %250, 2, %227

5:
Preds: 4
    %96, dead %97, dead %268 = ADCImm %251, 0, %95

    CmpBrImm %bb.17, undef $z, 1, %109, 31, implicit-def $c
    JMP %bb.3
  
  bb.17.for.inc14:
    successors: %bb.19(0x40000000), %bb.3(0x40000000)
  
    CmpBrImm %bb.19, undef $z, 1, %108, 255, implicit-def $c
    JMP %bb.3
  
  bb.19.for.inc14:
    successors: %bb.9(0x80000000)
  
    JMP %bb.9
  
  bb.9.for.inc17:
    successors: %bb.11(0x40000000), %bb.2(0x40000000)
  
1:
    %67, %68 = IncMB %258(tied-def 0), %259(tied-def 1), implicit-def $c, implicit-def $v

    CmpBrZero %bb.11, undef $z, 1, %68, implicit-def $c
    JMP %bb.2
  
  bb.11.for.inc17:
    successors: %bb.13(0x40000000), %bb.2(0x40000000)
  
    CmpBrImm %bb.13, undef $z, 1, %67, 11, implicit-def $c
    JMP %bb.2
  
  bb.13.for.inc17:
    successors: %bb.10(0x80000000)
  
    JMP %bb.10
  
  bb.10.for.end19:

1:
    $a = COPY %114

2:
    $x = COPY %115

    RTS implicit $a, implicit $x

...

Step: Split into atomic scheduling units, including stubs for MBB begin and end.
  - Counts can be per MBB; no need to schedule across
  - Skip nodes that don't need to be scheduled (PHIs, Terminators, vreg copies, REG_SEQUENCE)

Step: Find dead defs and mark them

Step: Mark precedent edges between scheduling units.
 - No preds across basic blocks
 - Vreg defs precede uses
 - Look through vreg copies and REG_SEQUENCE
 - ADJCALLSTACKDOWN precedes physreg defs before call
 - ADJCALLSTACKDOWN and earlier physreg defs before call precede call
 - call precedes ADJCALLSTACKUP

Step: Move vreg-def COPY and REG_SEQUENCE to right below their sources.

Step: Compute dominator tree and loop info
1
  2 header
    3 header
      8 latch 3
        17 latch 3, exiting 3
          19
            9 latch 2
              11 latch 2, exiting 2
                13
                  10
      4
        26
        7
        28
          5
            6 header
              23 latch 6, exiting 6
              25
              24 latch 6, exiting 6
        27

Registers are very, very sparse. It's unlikely that a value will be able to
live its whole life in a register, but if it can, it's imperative that it do
so. Let's start by weeding out impossibilities.

Step: Erase RCs and coalesce COPY; we'll recover them later.
