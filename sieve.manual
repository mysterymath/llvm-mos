body:             |
  bb.1.entry:
    successors: %bb.2(0x80000000)
2:
    %265 = LDImm target-flags(lo) @flags

3:
    %266 = LDImm target-flags(hi) @flags

    %267 = REG_SEQUENCE %265, %subreg.sublo, %266, %subreg.subhi

5:
    %2 = LDImm 1

6:
    %263 = LDImm -1

7:
    %264 = LDImm 31

8:
    %11 = LDImm 0

9:
    %262 = LDImm 3

11:
    %216 = LDImm 0

  bb.2.for.cond1.preheader:
    successors: %bb.3(0x80000000)
    %258 = PHI %2, %bb.1, %67, %bb.9, %67, %bb.11
    %259 = PHI %11, %bb.1, %68, %bb.9, %68, %bb.11

    ADJCALLSTACKDOWN 0, 0, implicit-def $rs0, implicit $rs0

3:
    $rs1 = COPY %267

4:
    $a = COPY %2

5:
    $x = COPY %263

6:
    $rc4 = COPY %264

    JSR &__memset, mos_csr, implicit $rs1, implicit $a, implicit $x, implicit $rc4
    ADJCALLSTACKUP 0, 0, implicit-def $rs0, implicit $rs0

  bb.3.for.body6:
    successors: %bb.8(0x30000000), %bb.4(0x50000000)
  
    %250 = PHI %262, %bb.2, %94, %bb.8, %94, %bb.17
    %251 = PHI %11, %bb.2, %96, %bb.8, %96, %bb.17
    %244 = PHI %262, %bb.2, %102, %bb.8, %102, %bb.17
    %245 = PHI %11, %bb.2, %104, %bb.8, %104, %bb.17
    %238 = PHI %11, %bb.2, %114, %bb.8, %114, %bb.17
    %239 = PHI %11, %bb.2, %115, %bb.8, %115, %bb.17
    %232 = PHI %11, %bb.2, %108, %bb.8, %108, %bb.17
    %233 = PHI %11, %bb.2, %109, %bb.8, %109, %bb.17

    $a = COPY %232
    $c = LDImm1 0
    $a, $c, dead $v = ADCImm $a, target-flags(lo) @flags, $c
    %218:imag16 = UNDEF
    %282:imag16 = INSERT_SUBREG $a, %218, sublo
    $a = COPY %233
    $a, dead $c, dead $v = ADCImm $a, target-flags(hi) @flags, $c
    %283:imag16 = INSERT_SUBREG $a, %282:imag16, subhi
    $y = COPY %216
    $a = LDIndirIdx %283, $y :: (load (s8) from %ir.arrayidx7, !tbaa !3)
    CmpBrZero %bb.8, undef $z, 1, $a, implicit-def $c
    JMP %bb.4
  
  bb.4.if.then:
    successors: %bb.26(0x40000000), %bb.27(0x40000000)

    %206, $c = ASL %232
    %208, dead $c = ROL %233, $c
    $a = COPY %206
    $c = LDImm1 0
    $a, $c, dead $v = ADCImag8 $a, %232, $c
    %197 = COPY $a
    $a = COPY %208
    $a, dead $c, dead $v = ADCImag8 $a, %233, $c
    %199 = COPY $a
    $a = COPY %197
    $c = LDImm1 0
    $a, $c, dead $v = ADCImm $a, 3, $c
    %188 = COPY $a
    $a = COPY %199
    $a, dead $c, dead $v = ADCImm $a, 0, $c
    %190 = COPY $a
    CmpBrImm %bb.26, undef $z, 1, $a, 31, implicit-def $c
    JMP %bb.27
  
  bb.26.if.then:
    successors: %bb.7(0x40000000), %bb.28(0x40000000)
  
    $c = CMPImm %188, 255
    GBR %bb.7, $c, 1, implicit-def $c
    JMP %bb.28
  
  bb.27.if.then:
    successors: %bb.7(0x40000000), %bb.28(0x40000000)
  
    $c = CMPImm %190, 31
    GBR %bb.7, $c, 1, implicit-def $c
    JMP %bb.28
  
  bb.28.if.then:
    successors: %bb.5(0x80000000)

    JMP %bb.5
  
  bb.5.while.body.preheader:
    successors: %bb.6(0x80000000)
  

  bb.6.while.body:
    successors: %bb.23(0x40000000), %bb.24(0x40000000)
  
    %164 = PHI %244, %bb.5, %144, %bb.23, %144, %bb.24
    %165 = PHI %245, %bb.5, %146, %bb.23, %146, %bb.24

    $a = COPY %164
    $c = LDImm1 0
    $a, $c, dead $v = ADCImm $a, target-flags(lo) @flags, $c
    %300 = UNDEF16
    %301 = INSERT_SUBREG %300, $a, sublo
    $a = COPY %165
    %158, dead %159, dead %276 = ADCImm $a, target-flags(hi) @flags, $c
    %151 = INSERT_SUBREG %158, %301, %subreg.subhi
    $a = LDImm 0
    $y = COPY %216
    STIndirIdx $a, %151, %216 :: (store (s8) into %ir.scevgep, !tbaa !3)
    $a = COPY %164
    $c = LDImm1 0
    $a, $c, dead $v = ADCImag8 $a, %250, $c
    %144 = COPY $a
    $a = COPY %165
    $a, dead $c, dead $v = ADCImag8 %165, %251, $c
    CmpBrImm %bb.23, undef $z, 1, $a, 31, implicit-def $c
    JMP %bb.24
  
  bb.23.while.body:
    successors: %bb.6(0x40000000), %bb.25(0x40000000)
  
    $c = CMPImm %144, 255
    GBR %bb.6, $c, 0, implicit-def $c
    JMP %bb.25
  
  bb.24.while.body:
    successors: %bb.6(0x40000000), %bb.25(0x40000000)
  
    $c = CMPImm %146, 31
    GBR %bb.6, $c, 0, implicit-def $c
    JMP %bb.25
  
  bb.25.while.body:
    successors: %bb.7(0x80000000)
  
    JMP %bb.7
  
  bb.7.while.end:
    successors: %bb.8(0x80000000)
  
    %118, %119 = IncMB %238(tied-def 0), %239(tied-def 1), implicit-def $c, implicit-def $v
  
  bb.8.for.inc14:
    successors: %bb.17(0x40000000), %bb.3(0x40000000)
  
    %114 = PHI %118, %bb.7, %238, %bb.3
    %115 = PHI %119, %bb.7, %239, %bb.3

1:
    %108, %109 = IncMB %232(tied-def 0), %233(tied-def 1), implicit-def $c, implicit-def $v

2:
    $a = COPY %244
    $c = LDImm1 0
    $a, $c, dead %271 = ADCImm $a, 3, $c
    %102 = COPY $a
    $a = COPY %245
    $a, dead $c, dead $v = ADCImm $a, 0, $c
    %104 = COPY $a

4:
    $a = COPY %250
    $c = LDImm1 0
    $a, $c, dead %269 = ADCImm $a, 2, $c
    %94 = COPY $a
    $a = COPY %251
    $a, dead $c, dead $v = ADCImm $a, 0, $c
    %96 = COPY $a

    CmpBrImm %bb.17, undef $z, 1, %109, 31, implicit-def $c
    JMP %bb.3
  
  bb.17.for.inc14:
    successors: %bb.19(0x40000000), %bb.3(0x40000000)
  
    CmpBrImm %bb.19, undef $z, 1, %108, 255, implicit-def $c
    JMP %bb.3
  
  bb.19.for.inc14:
    successors: %bb.9(0x80000000)
  
    JMP %bb.9
  
  bb.9.for.inc17:
    successors: %bb.11(0x40000000), %bb.2(0x40000000)
  
    %67, %68 = IncMB %258(tied-def 0), %259(tied-def 1), implicit-def $c, implicit-def $v
    CmpBrZero %bb.11, undef $z, 1, %68, implicit-def $c
    JMP %bb.2
  
  bb.11.for.inc17:
    successors: %bb.13(0x40000000), %bb.2(0x40000000)
  
    CmpBrImm %bb.13, undef $z, 1, %67, 11, implicit-def $c
    JMP %bb.2
  
  bb.13.for.inc17:
    successors: %bb.10(0x80000000)
  
    JMP %bb.10
  
  bb.10.for.end19:
1:
    $a = COPY %114

2:
    $x = COPY %115

    RTS implicit $a, implicit $x

...

Step: Split into atomic scheduling units, including stubs for MBB begin and end.
  - Counts can be per MBB; no need to schedule across
  - Skip nodes that don't need to be scheduled (PHIs, Terminators, vreg copies, REG_SEQUENCE)

Step: Find dead defs and mark them

Step: Mark precedent edges between scheduling units.
 - No preds across basic blocks
 - Vreg defs precede uses
 - Look through vreg copies and REG_SEQUENCE
 - ADJCALLSTACKDOWN precedes physreg defs before call
 - ADJCALLSTACKDOWN and earlier physreg defs before call precede call
 - call precedes ADJCALLSTACKUP

Step: Move vreg-def COPY and REG_SEQUENCE to right below their sources.

Step: Compute dominator tree and loop info
1
  2 header
    3 header
      8 latch 3
        17 latch 3, exiting 3
          19
            9 latch 2
              11 latch 2, exiting 2
                13
                  10
      4
        26
        7
        28
          5
            6 header
              23 latch 6, exiting 6
              25
              24 latch 6, exiting 6
        27

Registers are very, very sparse. It's unlikely that a value will be able to
live its whole life in a register, but if it can, it's imperative that it do
so. Let's start by weeding out impossibilities.

Step: Erase RCs and coalesce COPY; we'll recover them later.

Step: Do easy scheduling and scheduling on V, then C, then A, to join single RC
defs/uses with a compatible classes. Immediately rewrite to phys regs. Split
REG_SEQUENCE as parts are scheduled.

Step: Also, merge together scheduling units along those lines. Actually, *just*
do this; the rest will fall out. (e.g. first merge all V opportunities, then
all C opportunities, then all unique GPR opportunities, etc.). It's only an
opportunity if nothing if the preg is free between the two vreg copies on
either side of the link. Accordingly, we can just summarily rewrite!
 
Step: Replace constants of copies that have been clobbered with remats.
